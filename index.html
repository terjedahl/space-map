<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">

    <title>Space Maps</title>
    <style>
        body {
            margin:0;
            font-family: sans-serif;
            height: 100%;
            background-color: #e2e4e8;
            /*color: #333;*/
        }
        #header {
            position: absolute;
            top: 0; left: 0;
            padding: 20px;
            text-align: left;
            color: gray;
            font-size: 28px;
        }
        #container {
            position: relative;  /* makes this the origin of its children */
            width: 100%;
            height: 100%;
            overflow: hidden;
        }
        #c {
            width: 100%;  /* let our container decide our size */
            height: 100%;
            display: block;
        }
        /* .label added dynamically */
        .label {
            color: #FFF;
            font-family: sans-serif;
            padding: 2px;
            background: rgba(0, 0, 0, .6);
        }
    </style>
</head>
<body>

<div id="container">
    <canvas id="c"></canvas>
</div>
<div id="header">Space Maps</div>

<script src="js/three.js"></script>
<script src="js/controls/OrbitControls_custom.js"></script>
<script src="js/renderers/CSS2DRenderer.js"></script>
<script src="js/libs/dat.gui.min.js"></script>

<script>
    const AU = 1.0
    const LD = 0.002569 * AU // lunar distance
    const KM = AU / 149597870.7
    const PC = AU * 206264.81
    const LY = AU * 63241.08
    const OVERSIZE = 25 // Exaggerate size, so we can see it!
    const ENLARGE = 30

    const canvas = document.querySelector("#c");

    const celestials = [];  // Holds elements to be considered by updateLabelsVisibility
    const tempV = new THREE.Vector3(0,0,0); // used by updateLabelsVisibility
    const raycaster = new THREE.Raycaster();  // used by updateLabelsVisibility


    function toRad(deg) { return THREE.MathUtils.degToRad(deg) }

    function V(x, y, z) { return new THREE.Vector3(x, y, z) }

    const XV = V(1,0,0)
    const YV = V(0,1,0)
    const ZV = V(0,0,1)


    function rotate(obj, axisV, deg) {
        let cur = obj.quaternion
        let rot = new THREE.Quaternion().setFromAxisAngle(axisV, toRad(deg))
        cur.multiplyQuaternions(rot, cur)
        return obj
    }


    let helvetica_regular;
    function loadTypefaces(main_fn) {
        const loader = new THREE.FontLoader();
        loader.load(
            // resource URL
            'fonts/helvetiker_regular.typeface.json',
            // onLoad callback
            function ( typeface ) {
                helvetica_regular = typeface;
                main_fn();
                },
            // onProgress callback
            undefined,
            // onError callback
            function ( err ) { console.error( 'Loading font failed', err ); }
        );
    }


    function makeLabel(text) {
        const div = document.createElement( 'div' );
        div.className = 'label';
        div.textContent = text;
        div.style.marginTop = '-1em';
        return new THREE.CSS2DObject(div);
    }


    function setLabel(labeled, label, position) {
        if(position) {
            const [x,y,z] = position;
            label.position.set(x,y,z);
        }
        labeled.add(label);
        labeled.userData.label = label;
    }


    function line(start, end, color) {
        return new THREE.Line(
            new THREE.BufferGeometry().setFromPoints(
                [new THREE.Vector3(start[0],start[1],start[2]), new THREE.Vector3(end[0],end[1],end[2]) ] ),
                new THREE.LineBasicMaterial({color: color}) );
    }


    function sphere(location, radius, color, name="") {
        const mesh = new THREE.Mesh(
            new THREE.SphereGeometry(radius, 32, 32),
            new THREE.MeshPhongMaterial({color: color}))
            .translateX(location[0])
            .translateY(location[1])
            .translateZ(location[2])
        mesh.name = name
        return mesh
    }


    function circle(radius, color) {
        let segments = radius < 1 ? 36 : 36 * radius
        let cg = new THREE.CircleGeometry(radius, segments);
        cg.vertices.splice(0, 1);
        return new THREE.LineLoop(cg, new THREE.LineBasicMaterial({color: color}));
    }


    function disc(radius, color) {
        let segments = radius < 1 ? 36 : 36 * radius
        let cg = new THREE.CircleGeometry(radius, segments);
        return new THREE.Mesh(cg, new THREE.MeshBasicMaterial({color: color}));
    }


    function setProps(obj, orbitRadius, orbitSpeed, orbitAngle=0) {
        obj.userData.orbitRadius = orbitRadius
        obj.userData.orbitSpeed = orbitSpeed // in degrees? pr time?
        obj.userData.orbitAngle = orbitAngle   // how far the orbit has come
        return obj
    }


    function updateOrbit (obj) {
        const ud = obj.userData
        ud.orbitAngle += ud.orbitSpeed
        obj.position.x = ud.orbitRadius * Math.cos(ud.orbitAngle)
        obj.position.z = ud.orbitRadius * Math.sin(ud.orbitAngle) * -1
        return obj
    }


    function makeScene() {
        const scene = new THREE.Scene();
        scene.background = null;
        // scene.add(new THREE.AxesHelper(10));
        return scene
    }


    function makeCamera() {
        // TODO: Look into the first arg here! Is 60 better?
        const camera = new THREE.PerspectiveCamera(40, window.innerWidth / window.innerHeight, LD, LY);
        camera.position.set(-3.5*AU, 2.5*AU, 3.5*AU);
        camera.lookAt(0,0,0);
        return camera
    }

    function setLights(scene) {
        const lighting = new THREE.DirectionalLight("white", 0.7);
        lighting.position.set(-1, 2, 6);
        scene.add(lighting);

        const glow = new THREE.AmbientLight("white", 0.7);
        scene.add(glow);

        const sunlight = new THREE.PointLight("white", 0.7);
        sunlight.position.set(0,0,2);
        scene.add(sunlight);
        return scene
    }

    function makeRenderer() {
        let renderer = new THREE.WebGLRenderer({canvas: canvas, antialias: true, alpha: true});
        renderer.setPixelRatio(window.devicePixelRatio);
        renderer.setSize(window.innerWidth, window.innerHeight);
        return renderer
    }

    function makeLabelRenderer() {
        const labelRenderer = new THREE.CSS2DRenderer();
        labelRenderer.setSize(window.innerWidth, window.innerHeight);
        labelRenderer.domElement.style.position = 'absolute';
        labelRenderer.domElement.style.top = '0px';
        document.body.appendChild(labelRenderer.domElement);
        return labelRenderer
    }


    function makeTriangle(w,h,c,o) {
        const tr = new THREE.Shape()
        tr.moveTo(0,0)
        tr.lineTo(w/2,0)
        tr.lineTo(0,h)
        tr.lineTo(-w/2,0)
        tr.lineTo(0,0)

        return new THREE.Mesh(
            new THREE.ShapeGeometry(tr),
            new THREE.MeshBasicMaterial({color: c, side: THREE.DoubleSide, opacity: o, transparent: true}))
    }


    function makeText(text, size, color, opacity=1) {
        const mat =  new THREE.MeshBasicMaterial({color: color, side: THREE.DoubleSide, opacity: opacity, transparent: true})
        const geo = new THREE.ShapeBufferGeometry(helvetica_regular.generateShapes(text, size));
        geo.computeBoundingBox();
        const w = geo.boundingBox.max.x - geo.boundingBox.min.x;
        geo.translate(-0.5*w, 0, 0);
        return new THREE.Mesh(geo, mat);
    }


    function makePlane(innerRadius, color, label, zeroLabel) {
        // https://en.wikipedia.org/wiki/Celestial_coordinate_system
        const inner = innerRadius;
        const outer = innerRadius*1.5;

        const disc = new THREE.Mesh(
            new THREE.RingGeometry(inner, outer, 72),
            new THREE.MeshBasicMaterial({color: color, side: THREE.DoubleSide, opacity: 0.05, transparent: true}));

        [[0,1], [180,-1]].forEach(([deg,r]) => {
            let lr = makeText(label, .08*inner, color, .15);
            lr.position.set(0, r*.9*outer, 0);
            lr.rotateZ(toRad(deg));
            disc.add(lr);
        });

        [[0,[0,1]],[90,[-1,0]],[180,[0,-1]],[270,[1,0]]].forEach(([deg,[x,y]]) => {
            let t = makeTriangle(.3*inner,.25*inner, color, .05)
            let offset = outer;
            t.position.set(x*offset, y*offset,0)
            t.rotateZ(toRad(deg))
            disc.add(t);

            t = makeText(String(deg), .08*inner, color, .25);
            offset = outer-.16*inner;
            t.position.set(x*offset, y*offset,0)
            t.rotateZ(toRad(deg))
            disc.add(t);
        });

        if(zeroLabel) {
            let t0 = makeText(zeroLabel, .06*inner, color, .3);
            t0.position.set(0, 1.3*outer,0);
            disc.add(t0);
        }

        disc.rotateX(toRad(-90));
        const plane = new THREE.Group();
        plane.add(disc);

        // plane.add(new THREE.ArrowHelper(V(0,0,-1), V(0,0,-outer+head), head*2, color, head, head/3));  // 0 degrees
        // plane.add(new THREE.ArrowHelper(V(0,1,0), V(0,inner/10,0), inner/5, color))  // north

        return plane;
    }


    function makeGalacticPlane() {
        const r = 10*AU
        const c = 0xccaaaa
        const plane = new THREE.Group();
        plane.add(makePlane(2, "red", "\ngalactic plane\n", "galactic core\n  (27000 LY)"))
        const point = new THREE.Group();
        point.add(plane)
        point.userData["plane"] = plane;
        // point.add(new THREE.AxesHelper(3));
        return point
    }


    function makeEclipticPlane() {
        const r = .95*AU
        const c = "green"
        const plane = new THREE.Group();
        plane.add(makePlane(r, c, "\necliptic plane\n(heliocentric)", " \nvernal equinox"))
        const point = new THREE.Group();
        point.add(plane)
        point.userData["plane"] = plane;
        return point
    }


    function makeEquatorialPlane() {
        const r = 0.5*AU
        const c = "blue"
        const plane = new THREE.Group();
        plane.add(makePlane(r, c, "\nEquatorial plane\n"))
        const point = new THREE.Group();
        point.add(plane)
        point.userData["plane"] = plane;
        return point
    }


    function makeSun() {
        const r = 695700*KM * OVERSIZE;
        const sun = sphere([0, 0, 0], r, 0xcc9933, "Sun");
        setLabel(sun, makeLabel("Sol"), [0,r,r]);
        return sun
    }


    function makeEarth() {
        const r = 6371*KM * OVERSIZE*ENLARGE;
        const earth = new THREE.Group();
        const globe = sphere([0, 0,0], r, 0x4466cc, "Earth")
        setLabel(earth, makeLabel("Earth"), [0,r,r]);
        setProps(earth, 2, 0.01)
        globe.material.map = new THREE.TextureLoader().load("img/earthmap1k.jpg")
        // earth.rotation.y+=1
        // scene.add(circle(2, "gray"))  // earth's path
        // earth.add(new THREE.AxesHelper(.8*AU));
        earth.add(globe)
        earth.userData.globe = globe
        return earth
    }


    function makeMoon() {
        const ld = LD*OVERSIZE;
        const r = 1737*KM * OVERSIZE*ENLARGE;
        const moon = sphere([ld, 0, 0], r, "gray", "Moon")
        setLabel(moon, makeLabel("Moon"), [0,r,r]);
        setProps(moon, ld, 0.1)
        return moon
    }


    function updateLabelsVisibility() {
        // Shows / hides labels depending on the visiblity of the object they are labeling.
        // Based on:
        // https://threejsfundamentals.org/threejs/lessons/threejs-align-html-elements-to-3d.html

        celestials.forEach((labeled) => {
            const label = labeled.userData.label;
            if (!label) { return; }
            // Get the position of the center of the cube
            labeled.updateWorldMatrix(true, false);
            labeled.getWorldPosition(tempV);
            // Get the normalized screen coordinate of that position
            tempV.project(camera);
            // Ask the raycaster for all the objects that intersect from the eye toward this object's position
            raycaster.setFromCamera(tempV, camera);
            const intersectedObjects = raycaster.intersectObjects(celestials);
            // We're visible if the first intersection is this object.
            label.visible = intersectedObjects.length && labeled === intersectedObjects[0].object;
        });
    }


    // mechanism for pacing position updates
    let tickInterval = 1.0; // seconds
    let previousTick = 0
    function tick(timestamp, tickFn){
        if (timestamp > previousTick + tickInterval) {
            previousTick = timestamp;
            tickFn()
        }
    }


    function onWindowResize() {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
        labelRenderer.setSize(window.innerWidth, window.innerHeight);
    }


    const camera = makeCamera()

    const scene = makeScene()
    setLights(scene)

    const renderer = makeRenderer()

    const labelRenderer = makeLabelRenderer();

    let galactic, ecliptic, equatorial, sun, earth, moon, controls, gui;

    function main() {


        galactic = makeGalacticPlane()
        scene.add(galactic)

        ecliptic = makeEclipticPlane()
        rotate(ecliptic, XV, -62)
        rotate(ecliptic, YV, 90)
        galactic.add(ecliptic)

        equatorial = makeEquatorialPlane().translateZ(-AU)
        rotate(equatorial, ZV, 5)
        ecliptic.add(equatorial)

        sun = makeSun()
        ecliptic.add(sun)
        celestials.push(sun)

        earth = makeEarth()
        equatorial.add(earth)
        celestials.push(earth.userData.globe)

        moon = makeMoon()
        equatorial.add(moon)
        celestials.push(moon)

        // Note: control-keys inverted in source to make pan default and rotate override
        controls = new THREE.OrbitControls(camera, labelRenderer.domElement);
        controls.minDistance = LD;
        controls.maxDistance = LY;


        window.addEventListener('resize', onWindowResize, false);

        // http://learningthreejs.com/blog/2011/08/14/dat-gui-simple-ui-for-demos/
        // https://github.com/mrdoob/three.js/blob/dev/examples/jsm/libs/dat.gui.module.js
        gui = new dat.GUI({height : 5 * 32 - 1});
        // galactic.userData.plane.visible = false;
        gui.add(galactic.userData.plane, "visible").name("Galactic plane")
        gui.add(ecliptic.userData.plane, "visible").name("Ecliptic plane (heliocentric)")
        equatorial.userData.plane.visible = false;
        gui.add(equatorial.userData.plane, "visible").name("Equatorial plane (geocentric)")
        gui.add({reset: controls.reset}, "reset").name("Reset view")


        // function for updating positions based on absolute datetime
        const updatePositions = function() {
            // sun.rotation.z += 0.1;
            // earth.userData.globe.rotation.y += 0.2
            // updateOrbit(earth)
            updateOrbit(moon)
        }


        // animation loop
        function render(time) {
            time *= 0.001;  // convert time to seconds

            tick(time, updatePositions)

            controls.update();  // this call prevents labels from jittering when rotating
            renderer.render(scene, camera);
            updateLabelsVisibility();
            labelRenderer.render(scene, camera);

            requestAnimationFrame(render); // recur
        }
        requestAnimationFrame(render); // start render loop
    }

    loadTypefaces(main);

</script>
</body>
</html>